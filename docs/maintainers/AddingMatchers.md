## ContractCase Maintainer Documentation: How to add a new matcher

This describes the process to add in a new matcher for maintainers.
Adding a new matcher as a plugin will be a subset of these steps.

### Creating the types

First create the types in `packages/case-entities`. These describe
the raw data (mostly parameters if your matcher has any)

1.  All matchers much have a constant for the type of the matcher. The
    type must have an exported constant for its type. This is used to
    determine what type of matcher it is and to run the associated matching
    functions. For example:
    ```ts
    export const ARRAY_LENGTH_MATCHER_TYPE = 'ArrayLength' as const;
    ```
2.  Export a new interface that describes the actual matcher JSON. This is
    what will be written to the contract file, and generated by the matcher DSL.

    It must include `case:matcher:type`, set to the exact type constant string you created in the previous step.
    All parameter fields must be prefixed with `case:matcher:`. For example:

    ```ts
    export interface CoreArrayLengthMatcher {
      'case:matcher:type': typeof ARRAY_LENGTH_MATCHER_TYPE;
      'case:matcher:minLength': number;
      'case:matcher:maxLength': number;
    }
    ```

    If your matcher modifies the context, add fields prefixed with
    `case:context:` - these are automatically picked up by ContractCase and rolled
    into the context before this matcher is invoked (and passed down to any child matchers).

3.  Add these new types to both `AnyCaseNodeType` and `AnyCaseMatcher`:

    ```ts
    export type AnyCaseNodeType =
      // ...etc
      typeof ARRAY_LENGTH_MATCHER_TYPE;

    export type AnyCaseMatcher =
      // ...etc
      CoreArrayLengthMatcher;
    ```

### Creating the MatcherExecutor

Next, we will add the behaviour of the matcher, both for matching, and for
stripping the matchers. This goes in `packages/case-core`

1. Add a new `MatcherExecutor<typeof YOUR_NEW_TYPE>` in an appropriate place in `diffmatch`. A `MatcherExecutor` has four functions: `describe`, `check`, `strip`, and `validate`. For example:

   ```ts
   const describe: NameMatcherFn<
     CaseNodeFor<typeof ARRAY_LENGTH_MATCHER_TYPE>
   > = (
     matcher: CoreArrayLengthMatcher,
     matchContext: MatchContext,
   ): DescribeSegment =>
     describeMessage(
       `an array with length between ${matcher['_case:matcher:minLength']} and ${matcher['_case:matcher:maxLength']}`,
     );

   const strip: StripMatcherFn<CaseNodeFor<typeof ARRAY_LENGTH_MATCHER_TYPE>> = (
       matcher: CoreArrayLengthMatcher,
       matchContext: MatchContext
   ): AnyData => // implement the strip matcher function here


   const check: CheckMatchFn<CaseNodeFor<typeof ARRAY_LENGTH_MATCHER_TYPE>> = (
       matcher: CoreArrayLengthMatcher,
       matchContext: MatchContext,
       actual: unknown
   ): Promise<MatchResult> | MatchResult => // Implement your check here

   const validate: ValidateMatcherFn<
     CaseNodeFor<typeof ARRAY_LENGTH_MATCHER_TYPE>
   > = (
     matcher: CoreArrayLengthMatcher,
     matchContext: MatchContext,
   ): Promise<void> =>
     // Validate matcher configuration, eg check that minLength <= maxLength.
     // Throw CaseConfigurationError if invalid.
     Promise.resolve();

   export const ArrayLengthExecutor: MatcherExecutor<
       typeof ARRAY_LENGTH_MATCHER_TYPE,
       CaseNodeFor<typeof ARRAY_LENGTH_MATCHER_TYPE>
   > = { describe, check, strip, validate };
   ```

   #### The `describe` function

   The `describe` function returns a `DescribeSegment`, a structured description
   of the matcher in human-readable English. This is used for naming matchers
   (e.g., as lookup keys) and can also be used for pretty-printed output.

   **Important**: Any two matchers that produce the same rendered string (via
   `renderToString()`) **must** have the exact same matching behaviour in all
   cases. The core relies on this property.

   Use the helper functions from `@contract-case/case-plugin-base` to build descriptions:

   - `describeMessage('text')` — a plain text segment
   - `describeObject(entries)` — wraps key/value entries in `{}`, where `entries` is an array of `{ key: string, value: DescribeSegment }`
   - `describeArray(elements)` — wraps elements in `[]`, where `elements` is an array of `DescribeSegment`
   - `concatenateDescribe(segment1, segment2, ...)` — concatenates segments with no separator
   - `describeJoin(separator, segments)` — joins segments with a separator string

   For simple matchers, `describeMessage` is usually sufficient. For matchers
   with children, use `matchContext.descendAndDescribe()` to recurse into child
   matchers and combine the results with the helpers above. For example:

   ```ts
   // A simple leaf matcher
   describe: () => describeMessage('null')

   // A matcher with children that form an object
   describe: (matcher, context) =>
     concatenateDescribe(
       describeMessage('an object shaped like '),
       describeObject(
         Object.entries(matcher['_case:matcher:children']).map(
           ([key, child]) => ({
             key,
             value: context.descendAndDescribe(child, addLocation(key, context)),
           }),
         ),
       ),
     )
   ```

   If you need the description as a flat string (e.g., for embedding in error
   messages), use `renderToString()`.

   #### The other functions

   If you need to recurse further into any children of your matchers, use
   `matchContext.descendAndCheck()`, `matchContext.descendAndStrip()`, or
   `matchContext.descendAndDescribe()` as appropriate. See the existing matchers
   for examples.

   If your matcher doesn't have enough context to strip matchers (eg, for
   auxillery matchers designed to be used with `and()`), then throw a `new StripUnsupportedError(matcher, matchContext)` inside your implementation of `strip()`.

   Note that matcher executors are not allowed to call other matcher executors -
   only `descendAndCheck()`. If you need to combine matchers, do it at the DSL
   layer with `and()`

2. Add the matcher executor to `MatcherExecutors.ts`:
   ```ts
   export const MatcherExecutors: {
     [T in AnyCaseNodeType]: MatcherExecutor<T>;
   } = {
     // ...etc
     [ARRAY_LENGTH_MATCHER_TYPE]: ArrayLengthExecutor,
   };
   ```

### Create the matcher DSL

Create a DSL class in `packages/case-definition-dsl` that creates your matcher type, for example:

```ts
/**
 * Everything inside this matcher will be matched exactly, unless overridden
 * with a generic matcher (eg `AnyString` or` ShapedLike`). Use this to switch
 * out of `shapedLike` and back to the default exact matching.
 */
export class ExactlyLike extends CascadingContextMatcher {
  /**
   * @param content - The object, array, primitive or matcher to match exactly
   */
  constructor(content: AnyMatcherOrData) {
    super(content, { matchBy: 'exact' }, {});
  }

  /**
   * For non-TypeScript implementations (see `AnyMatcher.toJSON`)
   *
   * @privateRemarks
   * This comment and the implementation is boilerplate on all matchers to avoid
   * outputting duplicate unimportant documentation on all matcher classes of
   * the docs. Only modify this comment or the implementation via search and replace.
   */
  override toJSON(): unknown {
    return super.toJSON();
  }
}
```

You can also add a DSL function to the Jest boundary, for example:

```ts
/**
 * Everything inside this matcher will be matched exactly, unless overridden with an `any*` matcher
 *
 * Use this to switch out of `shapedLike` and back to the default exact matching.
 *
 * @param content What
 */
export const exactlyLike = (
  content: AnyCaseNodeOrData,
): CoreCascadingMatcher => ({
  'case:matcher:type': CASCADING_CONTEXT_MATCHER_TYPE,
  'case:matcher:child': content,
  'case:context:matchBy': 'exact',
});
```

If your matcher needs some double checking or additional processing (eg invoking
other matchers to make a composite matcher), do it in the DSL layer. The matcher
functions in the entities layer are intended to be data only.

### Test it

Add or create additional tests at the top level (see `index.*.spec.ts` for examples)
