## API Report File for "@contract-case/case-plugin-base"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AnyCaseMatcher } from '@contract-case/case-plugin-dsl-types';
import { AnyCaseMatcherOrData } from '@contract-case/case-plugin-dsl-types';
import { AnyData } from '@contract-case/case-plugin-dsl-types';
import { AnyLeafOrStructure } from '@contract-case/case-plugin-dsl-types';
import { AnyMockDescriptor } from '@contract-case/case-plugin-dsl-types';
import { AnyState } from '@contract-case/case-plugin-dsl-types';
import { CaseMockDescriptorFor } from '@contract-case/case-plugin-dsl-types';
import { InternalContractCaseCoreSetup } from '@contract-case/case-plugin-dsl-types';
import { LookupableMatcher } from '@contract-case/case-plugin-dsl-types';
import { SetupInfoFor } from '@contract-case/case-plugin-dsl-types';

// @public
export const actualToString: <T>(actual: T, indent?: number) => string;

// @public
export const addLocation: (location: string, context: MatchContext) => MatchContext;

// Warning: (ae-internal-missing-underscore) The name "applyNodeToContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const applyNodeToContext: (caseNodeOrData: AnyCaseMatcherOrData | AnyMockDescriptor, context: MatchContext, runConfig?: Partial<RunContext>) => MatchContext;

// @public
export const cantPublish: (context: MatchContext) => boolean;

// @public
export class CaseConfigurationError extends Error {
    constructor(message: string, context: LogLevelContext | 'DONT_ADD_LOCATION', code?: ConfigurationErrorCode, userFacingStackTrace?: string);
    contractCaseErrorCode: ConfigurationErrorCode;
    userFacingStackTrace: string;
}

// @public
export class CaseCoreError extends Error {
    constructor(message: string, context?: LogLevelContext, userFacingStackTrace?: string);
    // (undocumented)
    userFacingStackTrace: string;
}

// @public
export type CaseError = MatchingError | ConfigurationError | TriggerError | VerificationError | RawMatchError;

// Warning: (ae-forgotten-export) The symbol "SuccessfulCaseExample" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FailedCaseExample" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "PendingCaseExample" needs to be exported by the entry point index.d.ts
//
// @public
export type CaseExample = SuccessfulCaseExample | FailedCaseExample | PendingCaseExample;

// @public
export type CaseMatcherFor<KnownMatcherDescriptors, T extends string> = Extract<KnownMatcherDescriptors, IsCaseNodeForType<T>>;

// @public
export class CaseTriggerError extends Error {
    constructor(message: string, context?: LogLevelContext, userFacingStackTrace?: string);
    // (undocumented)
    userFacingStackTrace: string;
}

// @public
export type CheckMatchFn<T> = (matcher: T, matchContext: MatchContext, actual: unknown) => Promise<MatchResult> | MatchResult;

// @public
export const combineResultPromises: (...results: (MatchResult | Promise<MatchResult>)[]) => Promise<MatchResult>;

// @public @deprecated
export const combineResults: (...results: MatchResult[]) => MatchResult;

// @public
export interface ConfigurationError {
    code: string;
    // (undocumented)
    location: Array<string>;
    // (undocumented)
    message: string;
    // (undocumented)
    toString: () => string;
    // (undocumented)
    type: typeof ERROR_TYPE_CONFIGURATION;
}

// @public
export type ConfigurationErrorCode = keyof ErrorCodeDefinitions['configuration'];

// @public
export interface ConfigurationErrorCodes {
    BAD_DSL_DECLARATION: 'BAD_DSL_DECLARATION';
    BAD_INTERACTION_DEFINITION: 'BAD_INTERACTION_DEFINITION';
    CASE_CRASH_ADVICE: 'CASE_CRASH_ADVICE';
    DISK_IO_PROBLEM: 'DISK_IO_PROBLEM';
    FAKE_NEVER_CALLED: 'FAKE_NEVER_CALLED';
    INVALID_CONFIG: 'INVALID_CONFIG';
    INVALID_LIFECYCLE: 'INVALID_LIFECYCLE';
    MISSING_STATE_HANDLER: 'MISSING_STATE_HANDLER';
    MISSING_TEST_FUNCTION: 'MISSING_TEST_FUNCTION';
    MISSING_TRIGGER_FUNCTION: 'MISSING_TRIGGER_FUNCTION';
    NON_BROKERED_CONTRACT: 'NON_BROKERED_CONTRACT';
    OVERWRITE_CONTRACTS_NEEDED: 'OVERWRITE_CONTRACTS_NEEDED';
    UNDOCUMENTED: 'UNDOCUMENTED';
}

// Warning: (ae-internal-missing-underscore) The name "constructDataContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const constructDataContext: (makeLogger: (c: LogLevelContext) => Logger, resultPrinter: ResultFormatter, runConfig: Partial<RunContext>, defaults: Record<string, AnyData>, parentVersions: Array<string>) => DataContext;

// Warning: (ae-internal-missing-underscore) The name "constructMatchContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const constructMatchContext: (traversals: TraversalFns, makeLogger: (c: LogLevelContext) => Logger, makeLookup: (c: MatchContextWithoutLookup) => ContractLookupFns, resultPrinter: ResultFormatter, runConfig: Partial<RunContext>, defaults: Record<string, AnyData>, parentVersions: Array<string>) => MatchContext;

// @public
export type ContractCasePlugin<MatcherTypes extends string, MockTypes extends string, MatcherDescriptors extends IsCaseNodeForType<MatcherTypes>, MockDescriptors extends IsMockDescriptorForType<MockTypes>, AllSetupInfo> = {
    description: PluginDescription;
    matcherExecutors: {
        [T in MatcherTypes]: MatcherExecutor<T, CaseMatcherFor<MatcherDescriptors, T>>;
    };
    setupMocks: {
        [T in MockTypes]: MockExecutor<T, CaseMockDescriptorFor<MockDescriptors, T>, AllSetupInfo>;
    };
};

// Warning: (ae-internal-missing-underscore) The name "ContractFileConfig" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface ContractFileConfig {
    readonly '_case:currentRun:context:contractDir': string;
    readonly '_case:currentRun:context:contractFilename'?: string;
    readonly '_case:currentRun:context:contractsToWrite': Array<'main' | 'hash'>;
    readonly '_case:currentRun:context:overwriteFile'?: boolean;
    readonly '_case:currentRun:context:testRunId': string;
}

// @public
export interface ContractLookupFns {
    addDefaultVariable: (name: string, stateName: string, value: AnyCaseMatcherOrData) => [name: string, value: AnyCaseMatcherOrData];
    addStateVariable: (name: string, stateName: string, value: AnyCaseMatcherOrData) => [name: string, value: AnyCaseMatcherOrData];
    invokeFunctionByHandle: (handle: string, callerArguments: unknown[]) => Promise<unknown>;
    lookupMatcher: (uniqueName: string) => AnyCaseMatcherOrData;
    lookupVariable: (name: string) => AnyCaseMatcherOrData;
    saveLookupableMatcher: (matcher: AnyCaseMatcher) => void;
}

// @public
export const CORE_PLUGIN_PREFIX: "_CaseCore:";

// @public
export interface CoreErrorCodes {
    CASE_CRASH_ADVICE: 'CASE_CRASH_ADVICE';
}

// @public
export const coreLookupMatcher: (uniqueName: string, child: AnyCaseMatcherOrData) => LookupableMatcher;

// Warning: (ae-forgotten-export) The symbol "InjectableContext" needs to be exported by the entry point index.d.ts
// Warning: (ae-incompatible-release-tags) The symbol "DataContext" is marked as @public, but its signature references "ContractFileConfig" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "DataContext" is marked as @public, but its signature references "RunContext" which is marked as @internal
//
// @public
export type DataContext = DefaultContext & Partial<InjectableContext> & Partial<ContractFileConfig> & RunContext & LogLevelContext & LogContext;

// Warning: (ae-internal-missing-underscore) The name "DataOrCaseNodeFor" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type DataOrCaseNodeFor<KnownMatcherDescriptors, T extends string> = CaseMatcherFor<KnownMatcherDescriptors, T> | AnyLeafOrStructure;

// @public
export type DefaultContext = LogLevelContext & {
    readonly '_case:context:matchBy': typeof MATCH_BY_TYPE | typeof MATCH_BY_EXACT;
    readonly '_case:context:serialisableTo': typeof SERIALISABLE_TO_JSON;
    readonly '_case:currentRun:context:contractMode': 'write' | 'read';
    readonly '_case:currentRun:context:printResults': boolean;
    readonly '_case:currentRun:context:connectorClient': string;
    readonly '_case:currentRun:context:autoVersionFrom': 'TAG' | 'GIT_SHA';
};

// @public
export const defaultNameMock: <M extends AnyMockDescriptor>(mock: M, context: MatchContext) => M;

// @public
export const ERROR_TYPE_CONFIGURATION: "CONFIGURATION_ERROR";

// @public
export const ERROR_TYPE_MATCHING: "MATCHING_ERROR";

// @public
export const ERROR_TYPE_RAW_MATCH: "RAW_MATCH_ERROR";

// @public
export const ERROR_TYPE_TEST_RESPONSE: "TEST_RESPONSE_ERROR";

// @public
export const ERROR_TYPE_TRIGGER: "TRIGGER_FUNCTION_ERROR";

// @public
export interface ErrorAnnotations {
    actual?: string | undefined;
    expected?: string | undefined;
}

// @public
export type ErrorCodeDefinitions = {
    configuration: ConfigurationErrorCodes;
    core: CoreErrorCodes;
};

// @public
export const ErrorCodes: ErrorCodeDefinitions;

// @public
export const errorWhen: (test: boolean, err: CaseError | Array<CaseError>) => MatchResult;

// @public
export const failedExpectationError: (message: string, actual: unknown, code: string, context: MatchContext, expected: unknown, annotations?: ErrorAnnotations) => CaseError;

// Warning: (ae-internal-missing-underscore) The name "foldIntoContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const foldIntoContext: (caseNode: AnyCaseMatcher | AnyMockDescriptor, context: MatchContext) => MatchContext;

// @public
export const getPluginConfig: (context: DataContext, description: PluginDescription) => Record<string, unknown>;

// Warning: (ae-internal-missing-underscore) The name "HasBaseUrlUnderTest" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface HasBaseUrlUnderTest {
    // (undocumented)
    '_case:currentRun:context:baseUrlUnderTest': string;
}

// Warning: (ae-internal-missing-underscore) The name "HasContractFileConfig" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type HasContractFileConfig = DataContext & ContractFileConfig;

// @public
export const hasErrors: (result: MatchResult | CaseError[]) => boolean;

// @public
export type HasExample<T extends AnyCaseMatcher> = T & {
    '_case:matcher:example': unknown;
};

// @public
export const hasNoErrors: (result: MatchResult) => boolean;

// Warning: (ae-internal-missing-underscore) The name "HttpTestContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface HttpTestContext {
    // (undocumented)
    baseUrl: string;
}

// @public
export const isCaseNode: (maybeMatcher: unknown) => maybeMatcher is AnyCaseMatcher;

// @public
export interface IsCaseNodeForType<T extends string> {
    // (undocumented)
    '_case:matcher:type': T;
}

// @public
export interface IsMockDescriptorForType<T extends string> {
    // (undocumented)
    '_case:mock:type': T;
    // (undocumented)
    '_case:run:context:setup': InternalContractCaseCoreSetup;
}

// Warning: (ae-internal-missing-underscore) The name "locationString" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const locationString: (matchContext: LogLevelContext) => string;

// @public
export interface LogContext extends LogLevelContext {
    logger: Logger;
    makeLogger: (m: LogLevelContext) => Logger;
    // Warning: (ae-incompatible-release-tags) The symbol "resultPrinter" is marked as @public, but its signature references "ResultFormatter" which is marked as @internal
    resultPrinter: ResultFormatter;
}

// @public
export interface Logger {
    debug: (message: string, ...additional: unknown[]) => Promise<void>;
    deepMaintainerDebug: (message: string, ...additional: unknown[]) => Promise<void>;
    error: (message: string, ...additional: unknown[]) => Promise<void>;
    maintainerDebug: (message: string, ...additional: unknown[]) => Promise<void>;
    warn: (message: string, ...additional: unknown[]) => Promise<void>;
}

// @public
export type LogLevel = 'none' | 'error' | 'warn' | 'debug' | 'maintainerDebug' | 'deepMaintainerDebug';

// @public
export type LogLevelContext = {
    readonly '_case:currentRun:context:parentVersions': Array<string>;
    readonly '_case:currentRun:context:logLevel': LogLevel;
    readonly '_case:currentRun:context:location': Array<string>;
};

// @public
export const makeNoErrorResult: () => MatchResult;

// @public
export const makeResults: (...err: CaseError[]) => MatchResult;

// @public
export const MATCH_BY_EXACT: "exact";

// @public
export const MATCH_BY_TYPE: "type";

// Warning: (ae-forgotten-export) The symbol "HasMakeLookupFn" needs to be exported by the entry point index.d.ts
//
// @public
export type MatchContext = DataContext & TraversalFns & ContractLookupFns & HasMakeLookupFn;

// @public
export interface MatchContextByExact {
    // (undocumented)
    '_case:context:matchBy': 'exact';
}

// @public
export interface MatchContextByType {
    // (undocumented)
    '_case:context:matchBy': 'type';
}

// Warning: (ae-internal-missing-underscore) The name "MatchContextWithoutLookup" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type MatchContextWithoutLookup = Omit<MatchContext, keyof ContractLookupFns | keyof HasMakeLookupFn>;

// @public
export interface MatcherExecutor<MatcherType extends string, T extends IsCaseNodeForType<MatcherType>> {
    check: CheckMatchFn<T>;
    describe: NameMatcherFn<T>;
    strip: StripMatcherFn<T>;
    validate: ValidateMatcherFn<T>;
}

// @public
export const matcherToString: <T>(actual: T, indent?: number) => string;

// @public
export interface MatchingError {
    actual: unknown;
    annotations?: ErrorAnnotations;
    expected: unknown;
    location: Array<string>;
    matcher: AnyCaseMatcher;
    message: string;
    toString: () => string;
    // (undocumented)
    type: typeof ERROR_TYPE_MATCHING;
}

// @public
export const matchingError: (matcher: AnyCaseMatcher, message: string, actual: unknown, context: MatchContext, expected?: unknown, annotations?: ErrorAnnotations) => CaseError;

// @public
export type MatchResult = Array<CaseError>;

// Warning: (ae-internal-missing-underscore) The name "MockConfig" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface MockConfig {
    '_case:currentRun:context:mockConfig': Record<string, Record<string, unknown>>;
    '_case:currentRun:context:pluginProvided'?: Record<string, unknown>;
}

// @public
export type MockData<AllSetupInfo, T extends string> = {
    config: SetupInfoFor<AllSetupInfo, T>;
    assertableData: () => Promise<MockOutput>;
};

// @public
export type MockExecutor<MockType extends string, Descriptor extends IsMockDescriptorForType<MockType>, AllSetupInfo> = {
    executor: MockExecutorFn<Descriptor, AllSetupInfo, MockType>;
    ensureMatchersAreNamed: (mock: Descriptor, context: MatchContext) => Descriptor;
};

// @public
export type MockExecutorFn<Descriptor extends IsMockDescriptorForType<T>, AllSetupInfo, T extends string> = (mock: Descriptor, context: MatchContext) => Promise<MockData<AllSetupInfo, T>>;

// @public
export type MockOutput = {
    actual: unknown;
    expected: AnyCaseMatcherOrData;
    context: MatchContext;
};

// @public
export const mustResolveToNumber: (matcher: AnyCaseMatcherOrData, context: MatchContext) => number;

// @public
export const mustResolveToString: (matcher: AnyCaseMatcherOrData, context: MatchContext) => string;

// @public
export type NameMatcherFn<T> = (matcher: T, matchContext: MatchContext) => string;

// @public
export type PluginDescription = {
    humanReadableName: string;
    shortName: string;
    uniqueMachineName: string;
    version: string;
};

// @public
export const providePluginContext: (parentContext: MatchContext, providedContext: Record<string, string>) => MatchContext;

// Warning: (ae-internal-missing-underscore) The name "RawLookupFns" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface RawLookupFns {
    // (undocumented)
    addVariable: (name: string, type: 'default' | 'state', stateName: string, value: AnyCaseMatcherOrData, context: MatchContextWithoutLookup) => [name: string, value: AnyCaseMatcherOrData];
    // (undocumented)
    lookupMatcher: (uniqueName: string, context: MatchContextWithoutLookup) => AnyCaseMatcherOrData;
    // (undocumented)
    lookupVariable: (name: string, context: MatchContextWithoutLookup) => AnyCaseMatcherOrData;
    // (undocumented)
    saveLookupableMatcher: (matcher: AnyCaseMatcher, context: MatchContextWithoutLookup) => void;
}

// @public
export interface RawMatchError {
    actual: unknown;
    annotations?: ErrorAnnotations;
    code: string;
    expected: unknown;
    location: Array<string>;
    message: string;
    // (undocumented)
    toString: () => string;
    // (undocumented)
    type: typeof ERROR_TYPE_RAW_MATCH;
}

// Warning: (ae-internal-missing-underscore) The name "ResultFormatter" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type ResultFormatter = {
    printError: (e: CaseError, context: DataContext) => string;
    printSuccessTitle: (example: CaseExample, index: string, context: DataContext) => string;
    printFailureTitle: (example: CaseExample, index: string, context: DataContext) => string;
    printDownloadedContract: (filename: string, context: DataContext) => string;
};

// Warning: (ae-internal-missing-underscore) The name "RunContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface RunContext extends Partial<InjectableContext & LogLevelContext & HasBaseUrlUnderTest & ContractFileConfig & MockConfig> {
    // (undocumented)
    readonly '_case:currentRun:context:autoVersionFrom'?: 'TAG' | 'GIT_SHA';
    // (undocumented)
    readonly '_case:currentRun:context:brokerBaseUrl'?: string;
    // (undocumented)
    readonly '_case:currentRun:context:brokerBasicAuth'?: {
        username: string;
        password: string;
    };
    // (undocumented)
    readonly '_case:currentRun:context:brokerCiAccessToken'?: string;
    // (undocumented)
    readonly '_case:currentRun:context:changedContracts'?: 'FAIL' | 'OVERWRITE';
    // (undocumented)
    readonly '_case:currentRun:context:connectorClient': string;
    // (undocumented)
    readonly '_case:currentRun:context:defaultConfig': Record<string, AnyData>;
    // (undocumented)
    readonly '_case:currentRun:context:internals'?: {};
    // (undocumented)
    readonly '_case:currentRun:context:printResults': boolean;
    // (undocumented)
    readonly '_case:currentRun:context:publish'?: false | true | 'ONLY_IN_CI' | 'NEVER' | 'ALWAYS';
    // (undocumented)
    readonly '_case:currentRun:context:testName': string | 'OUTSIDE_TESTS';
    // (undocumented)
    readonly '_case:currentRun:context:throwOnFail'?: boolean;
    // (undocumented)
    readonly '_case:currentRun:context:variables': Record<string, AnyCaseMatcherOrData>;
}

// @public
export const SERIALISABLE_TO_JSON: "json";

// Warning: (ae-internal-missing-underscore) The name "shouldLog" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const shouldLog: (context: LogLevelContext, logLevel: LogLevel) => boolean;

// @public
export type StripMatcherFn<T> = (matcher: T, matchContext: MatchContext) => AnyData;

// @public
export class StripUnsupportedError extends Error {
    constructor(matcher: AnyCaseMatcher, context: DataContext);
}

// @public
export interface TraversalFns {
    descendAndCheck: <T extends AnyCaseMatcherOrData>(matcherOrData: T, parentMatchContext: MatchContext, actual: unknown) => Promise<MatchResult> | MatchResult;
    descendAndDescribe: (matcherOrData: AnyCaseMatcherOrData, parentMatchContext: MatchContext) => string;
    descendAndStrip: (matcherOrData: AnyCaseMatcherOrData, parentMatchContext: MatchContext) => AnyData;
    descendAndValidate: <T extends AnyCaseMatcherOrData>(matcherOrData: T, parentMatchContext: MatchContext) => Promise<void>;
    selfVerify: (matcherOrData: AnyCaseMatcherOrData, parentMatchContext: MatchContext) => Promise<void>;
}

// @public
export interface TriggerError {
    // (undocumented)
    code: string;
    // (undocumented)
    location: Array<string>;
    // (undocumented)
    message: string;
    // (undocumented)
    toString: () => string;
    // (undocumented)
    type: typeof ERROR_TYPE_TRIGGER;
    // (undocumented)
    userFacingStackTrace: string;
}

// @public
export type ValidateMatcherFn<T> = (matcher: T, matchContext: MatchContext) => Promise<void>;

// @public
export interface VerificationError {
    code: string;
    // (undocumented)
    error: VerifyTriggerReturnObjectError;
    // (undocumented)
    location: Array<string>;
    // (undocumented)
    message: string;
    // (undocumented)
    toString: () => string;
    // (undocumented)
    type: typeof ERROR_TYPE_TEST_RESPONSE;
}

// @public
export class VerifyTriggerReturnObjectError extends Error {
    constructor(cause: unknown, userFacingStackTrace?: string);
    // (undocumented)
    cause: unknown;
    // (undocumented)
    userFacingStackTrace: string;
}

// (No @packageDocumentation comment for this package)

```
